{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// react\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'; // third-party\n\nexport function useGlobalMousedown(callback, deps) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const memoCallback = useCallback(callback, deps || []);\n  useEffect(() => {\n    document.addEventListener('mousedown', memoCallback);\n    return () => document.removeEventListener('mousedown', memoCallback);\n  }, [memoCallback]);\n}\nexport function useDeferredData(source, defaultData, initialData, deps = []) {\n  const {\n    0: state,\n    1: setState\n  } = useState(() => ({\n    isLoading: initialData === undefined,\n    data: initialData || defaultData\n  }));\n  const memoizedSource = useCallback(source, deps);\n  const skipNextRef = useRef(initialData !== undefined);\n  useEffect(() => {\n    if (skipNextRef.current) {\n      skipNextRef.current = false;\n      return () => {};\n    }\n\n    let canceled = false;\n    setState(curState => {\n      if (!curState.isLoading) {\n        return _objectSpread(_objectSpread({}, curState), {}, {\n          isLoading: true\n        });\n      }\n\n      return curState;\n    });\n    memoizedSource().then(data => {\n      if (canceled) {\n        return;\n      }\n\n      setState(() => ({\n        isLoading: false,\n        data\n      }));\n    });\n    return () => {\n      canceled = true;\n    };\n  }, [memoizedSource]);\n  return state;\n}\nexport function useProductTabs(tabs, productsSource, initialData) {\n  const {\n    0: currentTabId,\n    1: setCurrentTabId\n  } = useState(1);\n  const memoizedTabs = useMemo(() => tabs.map(tab => _objectSpread(_objectSpread({}, tab), {}, {\n    current: currentTabId === tab.id\n  })), [tabs, currentTabId]);\n  const currentTab = memoizedTabs.find(x => x.current);\n  const products = useDeferredData(() => currentTab ? productsSource(currentTab) : Promise.resolve([]), [], initialData, [currentTab]);\n  const handleTabChange = useCallback(tab => {\n    setCurrentTabId(tab.id);\n  }, [setCurrentTabId]);\n  return useMemo(() => _objectSpread({\n    tabs: memoizedTabs,\n    handleTabChange\n  }, products), [memoizedTabs, handleTabChange, products]);\n}\nexport function useProductColumns(columns) {\n  const products = useDeferredData(() => Promise.all(columns.map(column => column.source())), [], undefined, [columns]);\n  return useMemo(() => columns.map((column, index) => _objectSpread(_objectSpread({}, column), {}, {\n    products: products.data[index] || []\n  })), [columns, products]);\n}\nexport function useDetachableForm(formMethods, detached) {\n  const {\n    register: originalRegister,\n    unregister,\n    trigger\n  } = formMethods;\n  const fieldNamesRef = useRef([]);\n  useEffect(() => {\n    if (detached) {\n      unregister(fieldNamesRef.current);\n      fieldNamesRef.current = [];\n      trigger([]).then();\n    }\n  }, [detached, unregister, trigger]);\n  return (rules = {}) => ref => {\n    if (!detached) {\n      if (ref && !fieldNamesRef.current.includes(ref.name)) {\n        fieldNamesRef.current.push(ref.name);\n      }\n\n      originalRegister(rules)(ref);\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}