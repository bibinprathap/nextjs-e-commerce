{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// react\nimport React, { useMemo } from 'react'; // third-party\n\nimport classNames from 'classnames';\nimport { FormattedMessage, useIntl } from 'react-intl';\nimport { useFormContext } from 'react-hook-form'; // application\n\nimport { useDetachableForm } from '~/services/hooks';\nimport { validateEmail } from '~/services/validators';\nexport function getRegisterFormDefaultValue(initialData = null) {\n  return _objectSpread({\n    email: '',\n    password: '',\n    confirmPassword: ''\n  }, initialData);\n}\n\nfunction RegisterForm(props) {\n  var _errors$email, _errors$email2, _errors$password, _errors$confirmPasswo, _errors$confirmPasswo2;\n\n  const {\n    namespace,\n    disabled,\n    idPrefix\n  } = props;\n  const formMethods = useFormContext();\n  const {\n    getValues,\n    errors: errorsProps\n  } = formMethods;\n  const errors = namespace ? errorsProps[namespace] : errorsProps;\n  const intl = useIntl();\n  const fieldId = idPrefix ? `${idPrefix}-` : '';\n  const ns = useMemo(() => namespace ? `${namespace}.` : '', [namespace]);\n  const register = useDetachableForm(formMethods, disabled || false);\n  return __jsx(React.Fragment, null, __jsx(\"div\", {\n    className: \"form-group\"\n  }, __jsx(\"label\", {\n    htmlFor: `${fieldId}email`\n  }, __jsx(FormattedMessage, {\n    id: \"INPUT_EMAIL_ADDRESS_LABEL\"\n  })), __jsx(\"input\", {\n    type: \"text\",\n    id: `${fieldId}email`,\n    name: `${ns}email`,\n    className: classNames('form-control', {\n      'is-invalid': errors === null || errors === void 0 ? void 0 : errors.email\n    }),\n    disabled: disabled,\n    placeholder: intl.formatMessage({\n      id: 'INPUT_EMAIL_ADDRESS_PLACEHOLDER'\n    }),\n    ref: register({\n      required: true,\n      validate: {\n        email: validateEmail\n      }\n    })\n  }), __jsx(\"div\", {\n    className: \"invalid-feedback\"\n  }, (errors === null || errors === void 0 ? void 0 : (_errors$email = errors.email) === null || _errors$email === void 0 ? void 0 : _errors$email.type) === 'required' && __jsx(FormattedMessage, {\n    id: \"ERROR_FORM_REQUIRED\"\n  }), (errors === null || errors === void 0 ? void 0 : (_errors$email2 = errors.email) === null || _errors$email2 === void 0 ? void 0 : _errors$email2.type) === 'email' && __jsx(FormattedMessage, {\n    id: \"ERROR_FORM_INCORRECT_EMAIL\"\n  }))), __jsx(\"div\", {\n    className: \"form-group\"\n  }, __jsx(\"label\", {\n    htmlFor: `${fieldId}password`\n  }, __jsx(FormattedMessage, {\n    id: \"INPUT_PASSWORD_LABEL\"\n  })), __jsx(\"input\", {\n    type: \"password\",\n    id: `${fieldId}password`,\n    name: `${ns}password`,\n    className: classNames('form-control', {\n      'is-invalid': errors === null || errors === void 0 ? void 0 : errors.password\n    }),\n    disabled: disabled,\n    placeholder: intl.formatMessage({\n      id: 'INPUT_PASSWORD_PLACEHOLDER'\n    }),\n    ref: register({\n      required: true\n    })\n  }), __jsx(\"div\", {\n    className: \"invalid-feedback\"\n  }, (errors === null || errors === void 0 ? void 0 : (_errors$password = errors.password) === null || _errors$password === void 0 ? void 0 : _errors$password.type) === 'required' && __jsx(FormattedMessage, {\n    id: \"ERROR_FORM_REQUIRED\"\n  }))), __jsx(\"div\", {\n    className: \"form-group mb-0\"\n  }, __jsx(\"label\", {\n    htmlFor: `${fieldId}confirm-password`\n  }, __jsx(FormattedMessage, {\n    id: \"INPUT_PASSWORD_REPEAT_LABEL\"\n  })), __jsx(\"input\", {\n    type: \"password\",\n    id: `${fieldId}confirm-password`,\n    name: `${ns}confirmPassword`,\n    className: classNames('form-control', {\n      'is-invalid': errors === null || errors === void 0 ? void 0 : errors.confirmPassword\n    }),\n    disabled: disabled,\n    placeholder: intl.formatMessage({\n      id: 'INPUT_PASSWORD_REPEAT_PLACEHOLDER'\n    }),\n    ref: register({\n      required: true,\n      validate: {\n        match: value => value === getValues(`${ns}password`)\n      }\n    })\n  }), __jsx(\"div\", {\n    className: \"invalid-feedback\"\n  }, (errors === null || errors === void 0 ? void 0 : (_errors$confirmPasswo = errors.confirmPassword) === null || _errors$confirmPasswo === void 0 ? void 0 : _errors$confirmPasswo.type) === 'required' && __jsx(FormattedMessage, {\n    id: \"ERROR_FORM_REQUIRED\"\n  }), (errors === null || errors === void 0 ? void 0 : (_errors$confirmPasswo2 = errors.confirmPassword) === null || _errors$confirmPasswo2 === void 0 ? void 0 : _errors$confirmPasswo2.type) === 'match' && __jsx(FormattedMessage, {\n    id: \"ERROR_FORM_PASSWORD_DOES_NOT_MATCH\"\n  }))));\n}\n\nexport default RegisterForm;","map":null,"metadata":{},"sourceType":"module"}