{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// react\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'; // third-party\n\nexport function useGlobalMousedown(callback, deps) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  var memoCallback = useCallback(callback, deps || []);\n  useEffect(function () {\n    document.addEventListener('mousedown', memoCallback);\n    return function () {\n      return document.removeEventListener('mousedown', memoCallback);\n    };\n  }, [memoCallback]);\n}\nexport function useDeferredData(source, defaultData, initialData) {\n  var deps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n  var _useState = useState(function () {\n    return {\n      isLoading: initialData === undefined,\n      data: initialData || defaultData\n    };\n  }),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var memoizedSource = useCallback(source, deps);\n  var skipNextRef = useRef(initialData !== undefined);\n  useEffect(function () {\n    if (skipNextRef.current) {\n      skipNextRef.current = false;\n      return function () {};\n    }\n\n    var canceled = false;\n    setState(function (curState) {\n      if (!curState.isLoading) {\n        return _objectSpread(_objectSpread({}, curState), {}, {\n          isLoading: true\n        });\n      }\n\n      return curState;\n    });\n    memoizedSource().then(function (data) {\n      if (canceled) {\n        return;\n      }\n\n      setState(function () {\n        return {\n          isLoading: false,\n          data: data\n        };\n      });\n    });\n    return function () {\n      canceled = true;\n    };\n  }, [memoizedSource]);\n  return state;\n}\nexport function useProductTabs(tabs, productsSource, initialData) {\n  var _useState2 = useState(1),\n      currentTabId = _useState2[0],\n      setCurrentTabId = _useState2[1];\n\n  var memoizedTabs = useMemo(function () {\n    return tabs.map(function (tab) {\n      return _objectSpread(_objectSpread({}, tab), {}, {\n        current: currentTabId === tab.id\n      });\n    });\n  }, [tabs, currentTabId]);\n  var currentTab = memoizedTabs.find(function (x) {\n    return x.current;\n  });\n  var products = useDeferredData(function () {\n    return currentTab ? productsSource(currentTab) : Promise.resolve([]);\n  }, [], initialData, [currentTab]);\n  var handleTabChange = useCallback(function (tab) {\n    setCurrentTabId(tab.id);\n  }, [setCurrentTabId]);\n  return useMemo(function () {\n    return _objectSpread({\n      tabs: memoizedTabs,\n      handleTabChange: handleTabChange\n    }, products);\n  }, [memoizedTabs, handleTabChange, products]);\n}\nexport function useProductColumns(columns) {\n  var products = useDeferredData(function () {\n    return Promise.all(columns.map(function (column) {\n      return column.source();\n    }));\n  }, [], undefined, [columns]);\n  return useMemo(function () {\n    return columns.map(function (column, index) {\n      return _objectSpread(_objectSpread({}, column), {}, {\n        products: products.data[index] || []\n      });\n    });\n  }, [columns, products]);\n}\nexport function useDetachableForm(formMethods, detached) {\n  var originalRegister = formMethods.register,\n      unregister = formMethods.unregister,\n      trigger = formMethods.trigger;\n  var fieldNamesRef = useRef([]);\n  useEffect(function () {\n    if (detached) {\n      unregister(fieldNamesRef.current);\n      fieldNamesRef.current = [];\n      trigger([]).then();\n    }\n  }, [detached, unregister, trigger]);\n  return function () {\n    var rules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return function (ref) {\n      if (!detached) {\n        if (ref && !fieldNamesRef.current.includes(ref.name)) {\n          fieldNamesRef.current.push(ref.name);\n        }\n\n        originalRegister(rules)(ref);\n      }\n    };\n  };\n}","map":null,"metadata":{},"sourceType":"module"}