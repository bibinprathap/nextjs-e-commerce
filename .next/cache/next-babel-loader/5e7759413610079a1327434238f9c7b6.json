{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nvar __jsx = React.createElement;\n// react\nimport React, { useCallback, useEffect, useMemo, useState } from 'react'; // third-party\n\nimport InputRange from 'react-input-range'; // application\n\nimport CurrencyFormat from '~/components/shared/CurrencyFormat';\nimport { useDirection } from '~/services/i18n/hooks';\n\nfunction getFirstValidValue() {\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n\n  return values.reduce(function (acc, value) {\n    return acc === null && (value || value === 0) ? value : acc;\n  }, null);\n}\n\nfunction FilterRange(props) {\n  var options = props.options,\n      value = props.value,\n      onChangeValue = props.onChangeValue;\n\n  var _ref = value || [],\n      _ref2 = _slicedToArray(_ref, 2),\n      propsFrom = _ref2[0],\n      propsTo = _ref2[1];\n\n  var _useState = useState(),\n      timer = _useState[0],\n      setTimer = _useState[1];\n\n  var _useState2 = useState([propsFrom, propsTo]),\n      state = _useState2[0],\n      setState = _useState2[1];\n\n  var _state = _slicedToArray(state, 2),\n      stateFrom = _state[0],\n      stateTo = _state[1];\n\n  var direction = useDirection();\n  var min = options.min,\n      max = options.max;\n  var from = Math.max(getFirstValidValue(stateFrom, propsFrom, min), min);\n  var to = Math.min(getFirstValidValue(stateTo, propsTo, max), max);\n  var fromLabel = from;\n  var toLabel = to; // since react-input-range does not support RTL direction,\n  // we just need to invert and swipe values\n\n  if (direction === 'rtl') {\n    var _ref3 = [to * -1, from * -1];\n    from = _ref3[0];\n    to = _ref3[1];\n    var _ref4 = [max * -1, min * -1];\n    min = _ref4[0];\n    max = _ref4[1];\n    fromLabel = from * -1;\n    toLabel = to * -1;\n  } // Update state from props.\n\n\n  useEffect(function () {\n    setState([propsFrom, propsTo]);\n  }, [propsFrom, propsTo]); // Clear previous timer.\n\n  useEffect(function () {\n    return function () {\n      clearTimeout(timer);\n    };\n  }, [timer]);\n  var handleChange = useCallback(function (newValue) {\n    var newFrom = newValue.min,\n        newTo = newValue.max; // This is needed to fix a bug in react-input-range.\n\n    var _ref5 = [Math.max(newFrom, min), Math.min(newTo, max)];\n    newFrom = _ref5[0];\n    newTo = _ref5[1];\n\n    // since react-input-range does not support RTL direction,\n    // we just need to invert and swipe values\n    if (direction === 'rtl') {\n      var _ref6 = [newTo * -1, newFrom * -1];\n      newFrom = _ref6[0];\n      newTo = _ref6[1];\n    }\n\n    setState([newFrom, newTo]);\n\n    if (onChangeValue) {\n      setTimer(setTimeout(function () {\n        onChangeValue({\n          filter: options,\n          value: [newFrom, newTo]\n        });\n      }, 250));\n    }\n  }, [min, max, options, onChangeValue, direction, setTimer, setState]);\n  return useMemo(function () {\n    return __jsx(\"div\", {\n      className: \"filter-range\"\n    }, __jsx(\"div\", {\n      className: \"filter-range__slider\",\n      dir: \"ltr\"\n    }, __jsx(InputRange, {\n      minValue: min,\n      maxValue: max,\n      value: {\n        min: from,\n        max: to\n      },\n      step: 1,\n      onChange: handleChange\n    })), __jsx(\"div\", {\n      className: \"filter-range__title-button\"\n    }, __jsx(\"div\", {\n      className: \"filter-range__title\"\n    }, __jsx(\"span\", {\n      className: \"filter-range__min-value\"\n    }, __jsx(CurrencyFormat, {\n      value: fromLabel\n    })), ' â€“ ', __jsx(\"span\", {\n      className: \"filter-range__max-value\"\n    }, __jsx(CurrencyFormat, {\n      value: toLabel\n    })))));\n  }, [min, max, from, to, fromLabel, toLabel, handleChange]);\n}\n\nexport default FilterRange;","map":null,"metadata":{},"sourceType":"module"}