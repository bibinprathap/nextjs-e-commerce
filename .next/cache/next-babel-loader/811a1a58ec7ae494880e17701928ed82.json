{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n// react\nimport React, { useCallback, useEffect, useRef, useState } from 'react'; // third-party\n\nimport classNames from 'classnames';\nimport Slick from 'react-slick'; // application\n\nimport { useDirection } from '~/services/i18n/hooks';\n\nfunction AppSlickInner(props) {\n  const {\n    children,\n    forwardRef,\n    beforeChange\n  } = props,\n        otherProps = _objectWithoutProperties(props, [\"children\", \"forwardRef\", \"beforeChange\"]);\n\n  const direction = useDirection();\n  const slickRef = useRef(null);\n  const originalSlickNextRef = useRef(() => {});\n  const originalSlickPrevRef = useRef(() => {});\n  const slickNextRef = useRef(() => {});\n  const slickPrevRef = useRef(() => {});\n\n  const getSlidesCount = () => React.Children.toArray(children).length;\n\n  const getSlidesToShow = () => {\n    const {\n      responsive,\n      slidesToShow\n    } = props;\n    let result = slidesToShow || 1;\n\n    if (false && responsive) {\n      responsive.forEach(options => {\n        if (options.settings === 'unslick') {\n          return;\n        }\n\n        const {\n          matches\n        } = matchMedia(`(max-width: ${options.breakpoint}px)`);\n\n        if (matches && options.settings.slidesToShow) {\n          result = options.settings.slidesToShow;\n        }\n      });\n    }\n\n    return result;\n  }; // react-slick has a bug due to which it is initialized\n  // with the incorrect position if the RTL property is true\n  // this function returns the correct values\n\n\n  const getStartPosition = () => {\n    let {\n      infinite\n    } = props;\n    infinite = infinite === true || infinite === undefined;\n\n    if (direction === 'ltr') {\n      return 0;\n    }\n\n    const slidesToShow = getSlidesToShow();\n    const slidesCount = getSlidesCount();\n\n    if (!infinite) {\n      return Math.max(0, slidesCount - slidesToShow);\n    }\n\n    return (Math.ceil(slidesCount / slidesToShow) - 1) * slidesToShow;\n  }; // returns indexes of active slides by currentIndex\n\n\n  const getActiveSlides = currentIndex => {\n    const slidesToShow = getSlidesToShow();\n    const activeSlides = [];\n    const slidesCount = getSlidesCount();\n    const firstSlide = Math.max(0, Math.min(slidesCount - slidesToShow, currentIndex));\n    const lastSlide = Math.min(slidesCount, firstSlide + slidesToShow);\n\n    for (let i = firstSlide; i < lastSlide; i += 1) {\n      activeSlides.push(i);\n    }\n\n    return activeSlides;\n  };\n\n  const {\n    0: preventClick,\n    1: setPreventClick\n  } = useState(false);\n  const {\n    0: activeSlides,\n    1: setActiveSlides\n  } = useState(getActiveSlides(getStartPosition()));\n\n  const onMousedown = event => {\n    const downX = event.screenX;\n    const downY = event.screenY;\n    let clickPrevented = false;\n\n    const onMousemove = moveEvent => {\n      if (clickPrevented) {\n        return;\n      } // Thank you Pythagoras.\n\n\n      const distance = Math.sqrt(Math.abs(downX - moveEvent.screenX) ** 2 + Math.abs(downY - moveEvent.screenY) ** 2);\n\n      if (moveEvent.cancelable && distance > 3) {\n        moveEvent.preventDefault();\n      }\n\n      if (distance > 15) {\n        clickPrevented = true;\n        setPreventClick(clickPrevented);\n      }\n    };\n\n    const onMouseup = () => {\n      clickPrevented = false;\n      setPreventClick(clickPrevented);\n      document.removeEventListener('mousemove', onMousemove);\n      document.removeEventListener('mouseup', onMouseup);\n    };\n\n    document.addEventListener('mousemove', onMousemove);\n    document.addEventListener('mouseup', onMouseup);\n  };\n\n  const setSlickRef = useCallback(ref => {\n    if (forwardRef) {\n      if ('current' in forwardRef) {\n        forwardRef.current = ref;\n      } else {\n        forwardRef(ref);\n      }\n    }\n\n    if (ref && ref !== slickRef.current) {\n      // react-slick forgot that if the RTL parameter is true,\n      // then the next and prev methods need to be swapped, so let's do it yourself\n      originalSlickNextRef.current = ref.slickNext;\n      originalSlickPrevRef.current = ref.slickPrev; // eslint-disable-next-line no-param-reassign\n\n      ref.slickNext = () => slickNextRef.current && slickNextRef.current(); // eslint-disable-next-line no-param-reassign\n\n\n      ref.slickPrev = () => slickPrevRef.current && slickPrevRef.current();\n    }\n\n    slickRef.current = ref;\n  }, []);\n  useEffect(() => {\n    slickNextRef.current = () => {\n      if (direction === 'rtl') {\n        originalSlickNextRef.current();\n      } else {\n        originalSlickNextRef.current();\n      }\n    };\n\n    slickPrevRef.current = () => {\n      if (direction === 'rtl') {\n        originalSlickNextRef.current();\n      } else {\n        originalSlickPrevRef.current();\n      }\n    };\n  }, [direction]); // If the slides have changed, we also need to change the active slides.\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setActiveSlides(getActiveSlides(getStartPosition()));\n    }, 0);\n    return () => {\n      clearTimeout(timer);\n    };\n  }, [children]); // Resets position when changing direction.\n\n  useEffect(() => {\n    if (slickRef.current) {\n      slickRef.current.slickGoTo(getStartPosition(), true);\n    }\n  }, [direction]);\n  const beforeChangeWrapper = useCallback((oldIndex, newIndex) => {\n    if (beforeChange) {\n      beforeChange(oldIndex, newIndex);\n    } // react-slick incorrectly adds the .slick-active class to slides\n    // if the RTL parameter is true so we will do it ourselves\n\n\n    setTimeout(() => {\n      setActiveSlides(getActiveSlides(newIndex));\n    }, 0);\n  }, [beforeChange]);\n  const classes = classNames('slick-prevent-click', {\n    'slick-prevent-click--active': preventClick\n  }); // we need to reverse slides if direction is RTL\n  // because react-slick displays them in the wrong order\n\n  let reversedChildren = React.Children.toArray(children);\n\n  if (direction === 'rtl') {\n    reversedChildren = reversedChildren.slice(0);\n    reversedChildren.reverse();\n  }\n\n  reversedChildren = reversedChildren.map((slide, index) => {\n    // react-slick incorrectly adds the .slick-active class to slides\n    // if the RTL parameter is true so we will do it ourselves\n    const slideClasses = classNames({\n      'correct-slick-active': activeSlides.includes(index)\n    });\n    return __jsx(\"div\", {\n      key: index,\n      dir: direction,\n      className: slideClasses\n    }, slide);\n  });\n  return (// eslint-disable-next-line jsx-a11y/no-static-element-interactions\n    __jsx(\"div\", {\n      className: classes,\n      onMouseDown: onMousedown\n    }, __jsx(Slick, _extends({}, otherProps, {\n      rtl: direction === 'rtl',\n      beforeChange: beforeChangeWrapper,\n      ref: setSlickRef\n    }), reversedChildren))\n  );\n}\n\nexport default React.forwardRef((props, ref) => {\n  const {\n    children\n  } = props;\n  return __jsx(AppSlickInner, _extends({\n    forwardRef: ref\n  }, props), children);\n});","map":null,"metadata":{},"sourceType":"module"}